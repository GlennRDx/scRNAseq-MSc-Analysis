tryCatch({
dir.create(full_pathway_name)
setwd(full_pathway_name)
pathview(gene.data = foldchanges,
pathway.id = pid,
species = 'mmu',
expand.node = F,
kegg.native = T,
low = list(gene = "red"),
mid =list(gene = "gray"),
high = list(gene = "green"))
},
error = function(e) {
cat(paste("Error for pathway", full_pathway_name, ":", e$message, "\n"))
})
setwd("..")
}
}
if (export_pathway_files == TRUE) {
# Export downregulated pathways
setwd(original_wd)
print(downregulated_pathway_ids)
export_pathways(downregulated_pathway_ids, downregulated_pathways, "Decreased")
# Export upregulated pathways
setwd(original_wd)
print(upregulated_pathway_ids)
export_pathways(upregulated_pathway_ids, upregulated_pathways, "Increased")
setwd(original_wd)
}
# Modify the ridge_data function to use different formatting for p-values and asterisks
ridge_data <- function(pathway_ids, pathway_pvals, pathway_direction, cats) {
ridge_df <- data.frame()
for (i in seq_along(pathway_ids)) {
pid <- pathway_ids[i]
pval <- pathway_pvals[i]
genes_in_pathway <- get_gene_list(pid, 'KEGG')
log2fc_values <- foldchanges[names(foldchanges) %in% genes_in_pathway$ENTREZID]
gene_ratio <- length(log2fc_values) / nrow(genes_in_pathway)  # Calculate gene ratio
if (length(log2fc_values) > 0) {  # Check if log2fc_values is not empty
pathway_category <- unique(cats[cats$Pathway == pid, "Major"])
pathway_subcategory <- unique(cats[cats$Pathway == pid, "Sub"])
if (length(pathway_category) == 0) {
pathway_category <- "Unknown"
}
if (length(pathway_subcategory) == 0) {
pathway_subcategory <- "Unknown"
}
pathway_name <- get_kegg_pathway_name(pid)
# Format p-value in scientific notation
pval_formatted <- formatC(pval, format = "e", digits = 2)
# Add stars based on significance level
stars <- ""
if (pval < 0.001) {
stars <- '<span style="font-family: monospace;">***</span>'
} else if (pval < 0.01) {
stars <- '<span style="font-family: monospace;">** </span>'  # Use two non-breaking spaces
} else if (pval < 0.05) {
stars <- '<span style="font-family: monospace;"> * </span>'  # Use three non-breaking spaces
}
# Format pathway label with name, p-value, and subcategory, with asterisks in monospace
pathway_label <- paste0(pathway_name, " - ", pid, ' - ', pathway_subcategory, " - p-val: ", pval_formatted, " ", stars)
ridge_df <- rbind(ridge_df, data.frame(pathway = rep(pathway_label, length(log2fc_values)),
log2fc = log2fc_values,
gene_ratio = rep(gene_ratio, length(log2fc_values)),
category = rep(pathway_category, length(log2fc_values)),
subcategory = rep(pathway_subcategory, length(log2fc_values))))
}
}
return(ridge_df)
}
# Updated the ridge_data function call with p-value formatting and star flagging
ridge_df_up <- ridge_data(upregulated_pathway_ids, upregulated_pvals, "Upregulated", cats)
ridge_df_down <- ridge_data(downregulated_pathway_ids, downregulated_pvals, "Downregulated", cats)
ridge_df <- rbind(ridge_df_up, ridge_df_down)
# Create a combined category for sorting
ridge_df$combined_category <- paste(ridge_df$category, ridge_df$subcategory, sep = " - ")
# Order by category and subcategory
ridge_df <- ridge_df %>%
arrange(category, subcategory)
# Create a factor to maintain the order in the plot
ridge_df$pathway <- factor(ridge_df$pathway, levels = unique(ridge_df$pathway))
# Function to save the ridge plot and ensure the Images directory exists
save_ridge_plot <- function(plot, file_name, path = 'Images') {
# Check if the directory exists, if not, create it
if (!dir.exists(path)) {
dir.create(path, recursive = TRUE)
}
full_path <- file.path(path, file_name)
ggsave(filename = full_path, plot = plot, device = "png", width = 20, height = 8, bg = "white")
}
# Plot ridge plots with binning
if (nrow(ridge_df) > 0) {
category_colors <- c("Metabolism" = "red1", "Genetic Information Processing" = "deepskyblue2",
"Environmental Information Processing" = "green3", "Cellular Processes" = "darkorchid1",
"Organismal Systems" = "orange", "Human Diseases" = "coral4", "Unknown" = "gray")
ridge_plot <- ggplot(ridge_df, aes(x = log2fc, y = pathway, fill = gene_ratio, color = category)) +
geom_density_ridges(scale = 3, rel_min_height = 0.01, linewidth = 1.5) +
geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.5) +
scale_fill_gradient(low = "white", high = "black", limits = c(0, 1), name = "Gene Ratio") +
scale_color_manual(values = category_colors) +
theme_ridges() +
theme(legend.position = "right",
axis.text.y = ggtext::element_markdown()) +  # Use ggtext to enable markdown rendering
labs(title = paste("Ridge Plots for", cell_type, "Pathways"),
x = "abs.log2FC",
y = "Pathways",
fill = "Gene Ratio",
color = "Category")
print(ridge_plot)
save_ridge_plot(ridge_plot, paste0(cell_type, "_KEGG_density_plot.png"))
} else {
cat("No data available for ridge plots.\n")
}
return(list(upregulated = upregulated_pathways, downregulated = downregulated_pathways, gobpres = gobpres, keggres = keggres))
}
##################### process multiple files function ###################
process_files <- function(input_directory, output_directory, p_val = 0.05, lfc = 0.1, export_pathway_files = TRUE, cats) {
# List all CSV files in the input directory
file_list <- list.files(path = input_directory, pattern = "\\.csv$", full.names = TRUE)
# Loop over each file in the file list
for (file_path in file_list) {
# Extract the file name and cell type
file_name <- basename(file_path)
parts <- strsplit(file_name, "_")[[1]]
cell_type <- paste(parts[6:length(parts)], collapse = "_")
cell_type <- sub("\\.csv$", "", cell_type) # Remove file extension '.csv'
cell_type <- gsub("_", " ", cell_type) # Replace underscores with spaces
print(file_name)
print(cell_type)
# Read the CSV file into a data frame
df <- read.csv(file_path)
# Run the analyze_pathways function
setwd(output_directory)
analyze_pathways(df, cell_type = cell_type, p_val = p_val, lfc = lfc, export_pathway_files = export_pathway_files, cats = cats)
}
}
########################## Pathway report function #############################
# Reports pathway metrics from a given deg file
pathway_report <- function(data, kegg_pathway, pval_threshold = 0.05) {
# Load necessary libraries
library(dplyr)
library(ggplot2)  # Library for plotting
# Ensure that the required columns are present in the data
if (!all(c("X", "adj.P.Val", "abs.log2FC") %in% colnames(data))) {
stop("The data must contain 'X', 'adj.P.Val', and 'abs.log2FC' columns.")
}
# Get the list of genes for the given KEGG pathway
gene_list <- get_gene_list(kegg_pathway, "KEGG")
# Ensure that the SYMBOL column is present in the gene_list
if (!"SYMBOL" %in% colnames(gene_list)) {
stop("The gene list must contain a 'SYMBOL' column.")
}
# Extract the gene symbols from the gene_list
kegg_genes <- gene_list$SYMBOL
# Find the intersecting genes
intersecting_genes <- data %>%
filter(X %in% kegg_genes) %>%
select(symbol = X, p.val = adj.P.Val, logFC = abs.log2FC) %>%
arrange(p.val)
# Calculate the number of significant genes
significant_genes <- intersecting_genes %>%
filter(p.val < pval_threshold)
# Calculate the gene ratio
total_intersecting <- nrow(intersecting_genes)
total_significant <- nrow(significant_genes)
gene_ratio_decimal <- if (total_intersecting > 0) {
total_significant / total_intersecting
} else {
NA  # Avoid division by zero
}
gene_ratio_fraction <- if (!is.na(gene_ratio_decimal) && total_intersecting > 0) {
paste(total_significant, total_intersecting, sep = "/")
} else {
NA  # Avoid division by zero
}
# Calculate the average logFC of the significant genes
avg_logFC <- if (total_significant > 0) {
mean(significant_genes$logFC, na.rm = TRUE)
} else {
NA  # If no significant genes, average is NA
}
# Create a distribution plot of the logFC for significant genes
if (total_significant > 0) {
p <- ggplot(significant_genes, aes(x = logFC)) +
geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
labs(title = "Distribution of logFC for Significant Genes",
x = "logFC",
y = "Count") +
theme_minimal()
print(p)  # Print the plot to the RStudio Plots pane
}
# Return results as a list
return(list(
intersecting_genes = intersecting_genes,
gene_ratio_decimal = gene_ratio_decimal,
gene_ratio_fraction = gene_ratio_fraction,
avg_logFC = avg_logFC
))
}
################################### Test Code ##################################
pathway_heatmap <- function(df_list, pid = NULL, scale_to_one = F, remove_na_rows = F, order_by_sum = T, custom_gene_list = NULL) {
# Step 1: Determine the gene list
if (!is.null(custom_gene_list)) {
gene_list <- unique(custom_gene_list)
} else if (!is.null(pid)) {
gene_list <- unique(get_gene_list(pid, 'KEGG')$SYMBOL)
} else {
stop("Either 'pid' or 'custom_gene_list' must be provided.")
}
# Initialize empty tables with appropriate dimensions
p_val <- data.frame(matrix(ncol = length(df_list), nrow = length(gene_list)))
logFC <- data.frame(matrix(ncol = length(df_list), nrow = length(gene_list)))
# Set row names and column names
rownames(p_val) <- gene_list
rownames(logFC) <- gene_list
colnames(p_val) <- names(df_list)
colnames(logFC) <- names(df_list)
# Step 2: Populate the tables using df$P.value and df$abs.log2FC
for (i in seq_along(df_list)) {
df <- df_list[[i]]
# Ensure the df has the required columns
if (!all(c("X", "adj.P.Val", "abs.log2FC") %in% colnames(df))) {
stop("Dataframe missing required columns.")
}
for (gene in gene_list) {
# Check if the gene exists in the current dataframe
if (gene %in% df$X) {
# Get the index of the gene
gene_idx <- which(df$X == gene)
# Populate p-value and logFC
p_val[gene, i] <- df$adj.P.Val[gene_idx]
# Set logFC to NaN if p-value is not significant
if (df$adj.P.Val[gene_idx] < 0.05) {
logFC[gene, i] <- df$abs.log2FC[gene_idx]
} else {
logFC[gene, i] <- NaN
}
}
}
}
# Conditionally remove rows that are entirely NAs
if (remove_na_rows) {
non_na_rows <- apply(p_val, 1, function(row) !all(is.na(row)))
p_val <- p_val[non_na_rows, ]
logFC <- logFC[non_na_rows, ]
} else {
# Move rows in p_val that are entirely NAs to the end
na_rows <- apply(p_val, 1, function(row) all(is.na(row)))
p_val <- rbind(p_val[!na_rows, ], p_val[na_rows, ])
logFC <- logFC[rownames(p_val), ]  # Ensure the order of logFC matches p_val
}
p_val_clean <- p_val
p_val_clean[is.na(p_val_clean)] <- 1  # Assuming 1 is a non-significant p-value
logFC_clean <- logFC
logFC_clean[is.na(logFC_clean)] <- 0  # Assuming 0 is a reasonable substitute for missing logFC
# Optionally sort the rows by the sum of significant logFC values
if (order_by_sum) {
significance_threshold <- 0.05  # Adjust this threshold if necessary
significant_logFC <- logFC_clean
significant_logFC[p_val_clean >= significance_threshold] <- 0  # Zero out non-significant logFC values
logFC_sums <- rowSums(significant_logFC, na.rm = TRUE)
# Order the rows by the sum of significant logFC values
logFC_clean <- logFC_clean[order(logFC_sums, decreasing = TRUE), ]
p_val_clean <- p_val_clean[rownames(logFC_clean), ]  # Ensure p_val matches the new order
}
# Determine the color scale range and create custom breaks
if (scale_to_one) {
max_abs_logFC <- max(abs(logFC_clean), na.rm = TRUE)
color_limits <- c(-1, 1)
if (max_abs_logFC > 1) {
color_limits <- c(-max_abs_logFC, max_abs_logFC)
}
} else {
color_limits <- c(-max(abs(logFC_clean), na.rm = TRUE), max(abs(logFC_clean), na.rm = TRUE))
}
breaks <- seq(color_limits[1], color_limits[2], length.out = 101)
color_palette <- colorRampPalette(c("red", "white", "green"))(100)
# Function to convert p-values to significance symbols
pval_to_significance <- function(p) {
if (p < 0.0001) {
return("****")
} else if (p < 0.001) {
return("***")
} else if (p < 0.01) {
return("**")
} else if (p < 0.05) {
return("*")
} else {
return("")
}
}
# Apply the function to the p-value table
significance_symbols <- apply(p_val_clean, c(1, 2), pval_to_significance)
# Generate the heatmap with significance annotations
pheatmap(logFC_clean,
main = paste0("Heatmap of logFC ", if (!is.null(pid)) pid else "Custom Genes"),
cluster_rows = !order_by_sum,  # Cluster rows if not ordering by sum
cluster_cols = F,
display_numbers = significance_symbols,
color = color_palette,
breaks = breaks,
border_color = NA,
fontsize = 10)
}
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu01212', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Load packages
library(clusterProfiler)
library(AnnotationDbi)
library(org.Mm.eg.db)
library(DOSE)
library(pathview)
library(dplyr)
library(enrichplot)
library(ggplot2)
library(stringr)
library(gage)
library(gageData)
library(tools)
library(ggridges)
library(viridis)
library(tidyverse)
library(KEGGREST)
library(ggtext)
library(pheatmap)
pathway_heatmap <- function(df_list, pid = NULL, scale_to_one = F, remove_na_rows = F, order_by_sum = T, custom_gene_list = NULL) {
# Step 1: Determine the gene list
if (!is.null(custom_gene_list)) {
gene_list <- unique(custom_gene_list)
} else if (!is.null(pid)) {
gene_list <- unique(get_gene_list(pid, 'KEGG')$SYMBOL)
} else {
stop("Either 'pid' or 'custom_gene_list' must be provided.")
}
# Initialize empty tables with appropriate dimensions
p_val <- data.frame(matrix(ncol = length(df_list), nrow = length(gene_list)))
logFC <- data.frame(matrix(ncol = length(df_list), nrow = length(gene_list)))
# Set row names and column names
rownames(p_val) <- gene_list
rownames(logFC) <- gene_list
colnames(p_val) <- names(df_list)
colnames(logFC) <- names(df_list)
# Step 2: Populate the tables using df$P.value and df$abs.log2FC
for (i in seq_along(df_list)) {
df <- df_list[[i]]
# Ensure the df has the required columns
if (!all(c("X", "adj.P.Val", "abs.log2FC") %in% colnames(df))) {
stop("Dataframe missing required columns.")
}
for (gene in gene_list) {
# Check if the gene exists in the current dataframe
if (gene %in% df$X) {
# Get the index of the gene
gene_idx <- which(df$X == gene)
# Populate p-value and logFC
p_val[gene, i] <- df$adj.P.Val[gene_idx]
# Set logFC to NaN if p-value is not significant
if (df$adj.P.Val[gene_idx] < 0.05) {
logFC[gene, i] <- df$abs.log2FC[gene_idx]
} else {
logFC[gene, i] <- NaN
}
}
}
}
# Conditionally remove rows that are entirely NAs
if (remove_na_rows) {
non_na_rows <- apply(p_val, 1, function(row) !all(is.na(row)))
p_val <- p_val[non_na_rows, ]
logFC <- logFC[non_na_rows, ]
} else {
# Move rows in p_val that are entirely NAs to the end
na_rows <- apply(p_val, 1, function(row) all(is.na(row)))
p_val <- rbind(p_val[!na_rows, ], p_val[na_rows, ])
logFC <- logFC[rownames(p_val), ]  # Ensure the order of logFC matches p_val
}
p_val_clean <- p_val
p_val_clean[is.na(p_val_clean)] <- 1  # Assuming 1 is a non-significant p-value
logFC_clean <- logFC
logFC_clean[is.na(logFC_clean)] <- 0  # Assuming 0 is a reasonable substitute for missing logFC
# Optionally sort the rows by the sum of significant logFC values
if (order_by_sum) {
significance_threshold <- 0.05  # Adjust this threshold if necessary
significant_logFC <- logFC_clean
significant_logFC[p_val_clean >= significance_threshold] <- 0  # Zero out non-significant logFC values
logFC_sums <- rowSums(significant_logFC, na.rm = TRUE)
# Order the rows by the sum of significant logFC values
logFC_clean <- logFC_clean[order(logFC_sums, decreasing = TRUE), ]
p_val_clean <- p_val_clean[rownames(logFC_clean), ]  # Ensure p_val matches the new order
}
# Determine the color scale range and create custom breaks
if (scale_to_one) {
max_abs_logFC <- max(abs(logFC_clean), na.rm = TRUE)
color_limits <- c(-1, 1)
if (max_abs_logFC > 1) {
color_limits <- c(-max_abs_logFC, max_abs_logFC)
}
} else {
color_limits <- c(-max(abs(logFC_clean), na.rm = TRUE), max(abs(logFC_clean), na.rm = TRUE))
}
breaks <- seq(color_limits[1], color_limits[2], length.out = 101)
color_palette <- colorRampPalette(c("red", "white", "green"))(100)
# Function to convert p-values to significance symbols
pval_to_significance <- function(p) {
if (p < 0.0001) {
return("****")
} else if (p < 0.001) {
return("***")
} else if (p < 0.01) {
return("**")
} else if (p < 0.05) {
return("*")
} else {
return("")
}
}
# Apply the function to the p-value table
significance_symbols <- apply(p_val_clean, c(1, 2), pval_to_significance)
# Generate the heatmap with significance annotations
pheatmap(logFC_clean,
main = paste0("Heatmap of logFC ", if (!is.null(pid)) pid else "Custom Genes"),
cluster_rows = !order_by_sum,  # Cluster rows if not ordering by sum
cluster_cols = F,
display_numbers = significance_symbols,
color = color_palette,
breaks = breaks,
border_color = NA,
fontsize = 10)
}
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu01212', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu00190', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Example usage with a custom gene list
genes <- unique(unlist(lapply(df_list, function(df) df$X)))
hsp_genes <- genes[grepl("^hsp", genes, ignore.case = TRUE)]
pathway_heatmap(df_list, custom_gene_list = hsp_genes, scale_to_one = T, remove_na_rows = T, order_by_sum = T)
# Look at KEGG pathway graph of specific pathway
specific_pathway_analysis = function(df, pid, p_val = 0.05){
owd = getwd()
setwd("/home/glennrdx/Documents/Research_Project/scRNAseq-MSc-Analysis/downstream_analysis/KEGG_Results/crypt/Individual_Pathway_Analysis")
df <- df[df$adj.P.Val <= p_val, ]
# Extract gene symbols
gene_symbols <- df$X
# Map gene symbols to Entrez IDs
gene_entrez_ids <- mapIds(org.Mm.eg.db, keys = gene_symbols, column = "ENTREZID", keytype = "SYMBOL", multiVals = "first")
gene_entrez_ids <- as.character(gene_entrez_ids)
# Prepare fold changes data
foldchanges <- df$abs.log2FC
names(foldchanges) <- gene_entrez_ids
foldchanges <- na.omit(foldchanges)
pathview(gene.data = foldchanges,
pathway.id = pid,
species = 'mmu',
expand.node = T,
kegg.native = T,
low = list(gene = "red"),
mid =list(gene = "gray"),
high = list(gene = "green"))
setwd(owd)
}
specific_pathway_analysis(df_ent, pid = 'mmu03050', p_val = 0.05)
specific_pathway_analysis(df_ent, pid = 'mmu03050', p_val = 0.05)
# Look at KEGG pathway graph of specific pathway
specific_pathway_analysis = function(df, pid, p_val = 0.05){
owd = getwd()
setwd("/home/glennrdx/Documents/Research_Project/scRNAseq-MSc-Analysis/downstream_analysis/KEGG_Results/crypt/Individual_Pathway_Analysis")
df <- df[df$adj.P.Val <= p_val, ]
# Extract gene symbols
gene_symbols <- df$X
# Map gene symbols to Entrez IDs
gene_entrez_ids <- mapIds(org.Mm.eg.db, keys = gene_symbols, column = "ENTREZID", keytype = "SYMBOL", multiVals = "first")
gene_entrez_ids <- as.character(gene_entrez_ids)
# Prepare fold changes data
foldchanges <- df$abs.log2FC
names(foldchanges) <- gene_entrez_ids
foldchanges <- na.omit(foldchanges)
pathview(gene.data = foldchanges,
pathway.id = pid,
species = 'mmu',
expand.node = T,
kegg.native = T,
low = list(gene = "red"),
mid =list(gene = "gray"),
high = list(gene = "green"))
setwd(owd)
}
specific_pathway_analysis(df_ent, pid = 'mmu03050', p_val = 0.05)
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu03050', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu04930', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
specific_pathway_analysis(df_ent, pid = 'mmu04930', p_val = 0.05)
specific_pathway_analysis(df_ent, pid = 'mmu04151', p_val = 0.05)
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu04151', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Example usage with KEGG pathway
pathway_heatmap(df_list, pid = 'mmu04630', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
specific_pathway_analysis(df_ent, pid = 'mmu04630', p_val = 0.05)
specific_pathway_analysis(df_ent, pid = 'mmu04910', p_val = 0.05)
specific_pathway_analysis(df_ent, pid = 'mmu04141', p_val = 0.05)
specific_pathway_analysis(df_ent, pid = 'mmu04140', p_val = 0.05)
specific_pathway_analysis(df_isc, pid = 'mmu04140', p_val = 0.05)
pathway_report(df_isc, kegg_pathway = 'mmu04530')
# Pathway
pathway =
# Individual specific pathway analysis - Gene Heatmap
pathway_heatmap(df_list, pid = 'mmu04630', scale_to_one = T, remove_na_rows = F, order_by_sum = T)
# Pathway
pathway = 'mmu04630'
# Individual specific pathway analysis - Gene Heatmap
pathway_heatmap(df_list, pid = pathway, scale_to_one = T, remove_na_rows = F, order_by_sum = T)
